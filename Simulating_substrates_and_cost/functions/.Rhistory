substrate <- terra::ifel(substrate >= 1, 1, 0)
substrate[is.na(substrate)] <- 0
# Force raster to materialize in memory
#substrate <- terra::deepcopy(substrate)
#substrate <- terra::setValues(substrate, terra::values(substrate))
# If you less than or qual the threshold you get a 1 (this is open area/cost2), otherwise 0 (its closed/cost1)
# Now safely build travel cost layer
travel_cost <- substrate
vals <- terra::values(substrate)
vals[vals == 1] <- cost1
vals[vals == 0] <- cost0
travel_cost <- terra::setValues(travel_cost, vals)
### 5. Crop extent
crop_ext <- terra::ext(mod, grid_size - mod, mod, grid_size - mod)
substrate_crop <- terra::crop(substrate, crop_ext)
resource_crop <- terra::crop(resource, crop_ext)
travel_cost_crop <- terra::crop(travel_cost, crop_ext)
### 6. Convert to raster for gdistance
travel_cost_raster <- raster::raster(travel_cost_crop)
resource_raster <- raster::raster(resource_crop)
### 7. Build gdistance transition object
tr <- gdistance::transition(1 / travel_cost_raster, transitionFunction = mean, directions = 8)
trC <- gdistance::geoCorrection(tr, type = "c")
### 8. Cost surface to nearest resource
resource_coords <- raster::xyFromCell(resource_raster,
which(raster::values(resource_raster) == 1))
if (nrow(resource_coords) == 0) {
warning("No resource cells found, skipping iteration.")
return(NULL)
}
cost_to_resources <- tryCatch({
gdistance::accCost(trC, resource_coords)
}, error = function(e) return(NULL))
if (is.null(cost_to_resources)) {
warning("accCost failed for resource_coords, skipping iteration.")
return(NULL)
}
cost_surface_terra <- terra::rast(cost_to_resources)
### 9. Pick start point far from resources
non_resource_cells <- which(raster::values(resource_raster) == 0)
if (length(non_resource_cells) == 0) {
warning("No non-resource cells found, skipping iteration.")
return(NULL)
}
sample_cells <- sample(non_resource_cells, min(100, length(non_resource_cells)))
sample_coords <- raster::xyFromCell(resource_raster, sample_cells)
distances <- sapply(seq_len(nrow(sample_coords)), function(i) {
xy <- sample_coords[i, , drop = FALSE]
cost_from_xy <- tryCatch(gdistance::accCost(trC, xy), error = function(e) return(NULL))
if (is.null(cost_from_xy)) return(NA)
min(raster::values(cost_from_xy)[raster::values(resource_raster) == 1], na.rm = TRUE)
})
if (all(is.na(distances))) {
warning("All distances NA â€” disconnected landscape. Skipping iteration.")
return(NULL)
}
distances[!is.finite(distances)] <- NA
start_cell <- sample_cells[which.max(distances)]
xy_start <- raster::xyFromCell(resource_raster, start_cell)
### 10. Least-cost path
cost_from_start <- tryCatch({
gdistance::accCost(trC, xy_start)
}, error = function(e) return(NULL))
if (is.null(cost_from_start)) {
warning("Failed to compute accCost from start, skipping iteration.")
return(NULL)
}
resource_cost_values <- terra::extract(terra::rast(cost_from_start), resource_coords)
if (all(is.na(resource_cost_values[,1]))) {
warning("No reachable resource from start, skipping iteration.")
return(NULL)
}
nearest_resource_idx <- which.min(resource_cost_values[,1])
xy_nearest_resource <- resource_coords[nearest_resource_idx, , drop = FALSE]
lcp <- tryCatch({
gdistance::shortestPath(trC, xy_start, xy_nearest_resource, output = "SpatialLines")
}, error = function(e) return(NULL))
if (is.null(lcp)) {
warning("shortestPath failed, skipping iteration.")
return(NULL)
}
lcp_terra <- terra::vect(lcp)
total_cum_cost <- terra::extract(terra::rast(cost_from_start),
terra::vect(matrix(xy_nearest_resource, ncol = 2))) |>
as.numeric()
final_list <- list(cost_surface_terra,lcp_terra, total_cum_cost, xy_start, xy_nearest_resource)
return(final_list)
}
## Iterated Djikstra sim.
##
# install.packages(c("terra", "gdistance"))
library(terra)
library(gdistance)
library(here)
setwd(paste(here::here(),"/Simulating_substrates_and_cost/functions",sep="",collapse=""))
source("functions_V3.R")
#set.seed(42)
### 1. Create base landscape
n <- 100  # grid size
mod <- 5 # number of cells to remove from each side
#cost1<-1
#cost2<-3
cost0=1 ## Keep this as a baseline this is the closed substrate
cost1=1.5## Vary the cost of second substrate (open)
c1_fraction=.2
c1_cluster_size=5
resource_cluster_size=5
output <- model_landscape_and_movement(grid_size=n,
mod=mod,
cost0=cost0,
cost1=cost1,
c1_fraction =c1_fraction[i],
c1_cluster_size = c1_cluster_size,
resource_cluster_size=resource_cluster_size)
output
plot(output[[1)]]
plot(output[[1]])
calculate_path_metrics(output[[1]],output[[2]])
## Iterated Djikstra sim.
##
# install.packages(c("terra", "gdistance"))
library(terra)
library(gdistance)
library(here)
setwd(paste(here::here(),"/Simulating_substrates_and_cost/functions",sep="",collapse=""))
source("functions_V3.R")
### 1. Create base landscape
n <- 100  # grid size
mod <- 5 # number of cells to remove from each side
#cost1<-1
#cost2<-3
k<-5   # Simulations per variable combo
cost_tape0<-c(1) ## Keep this as a baseline this is the closed substrate
cost_tape1<-c(1.5,2.5,3.5,4.5) ## Vary the cost of second substrate (open)
target_open_fraction=c(.1,.2,.3,.4) ##
closed_cluster_size=5
resource_cluster_size=5
metadata<-paste("targ", target_open_fraction,
"_cl_size", closed_cluster_size,
#                "_r_p", resource_prob,
"_r_size", resource_cluster_size,collapse="",sep="")
set.seed(100)
results <- data.frame(
total_length = numeric(),
euclidean = numeric(),
sinuosity = numeric(),
total_cost=numeric(),
cost1 = numeric(),
cost2 = numeric(),
replicate = integer()
)
#preallocate grid
param_grid <- expand.grid(cost0 = cost_tape0,
cost1 = cost_tape1,
c1_fraction=target_open_fraction,
replicate = seq_len(k))
param_grid
n_total <- nrow(param_grid)
param_grid$metadata<-metadata
# Example data frame to store results
param_grid$total_length <- NA
param_grid$euclidean <- NA
param_grid$sinuosity <- NA
param_grid$total_cost <- NA
for(i in 1:nrow(param_grid)){
#output <- model_landscape_and_movement_v8(n, mod, param_grid$cost1[i],param_grid$cost2[i])
output <- model_landscape_and_movement(grid_size=n,
mod=mod,
cost0=param_grid$cost0[i],
cost1=param_grid$cost1[i],
c1_fraction =param_grid$c1_fraction[i],
c1_cluster_size = closed_cluster_size,
resource_cluster_size=resource_cluster_size)
if (is.null(output)) {
next  # skip this iteration
}
# calculate metrics
metrics <- calculate_path_metrics(output[[1]], output[[2]])
# store results
param_grid$total_length[i] <- metrics$total_length
param_grid$euclidean[i] <- metrics$euclidean
param_grid$sinuosity[i] <- metrics$sinuosity
param_grid$total_cost[i] <- metrics$total_cost
}
param_grid
#Basic plots.
df<-param_grid
length(df$cost0)
df <- df[df$total_length > 0, ]
df <- df[which(df$total_cost>0),]
df$rat <- df$total_cost / df$total_length
ggplot(df, aes(x=rat,y=as.factor(c1_fraction),fill=as.factor(c1_fraction)))+geom_density_ridges()+
facet_wrap(~cost1)
ggplot(df, aes(x=sinuosity,y=as.factor(c1_fraction),fill=as.factor(c1_fraction)))+geom_density_ridges()+
facet_wrap(~cost1)
## Iterated Djikstra sim.
##
# install.packages(c("terra", "gdistance"))
library(terra)
library(gdistance)
library(here)
setwd(paste(here::here(),"/Simulating_substrates_and_cost/functions",sep="",collapse=""))
source("functions_V4.R")
#set.seed(42)
### 1. Create base landscape
n <- 100  # grid size
mod <- 5 # number of cells to remove from each side
#cost1<-1
#cost2<-3
k<-5   # Simulations per variable combo
cost_tape0<-c(1) ## Keep this as a baseline this is the closed substrate
cost_tape1<-c(1.5,2.5,3.5,4.5) ## Vary the cost of second substrate (open)
target_open_fraction=c(.1,.2,.3,.4) ##
closed_cluster_size=5
resource_cluster_size=5
metadata<-paste("targ", target_open_fraction,
"_cl_size", closed_cluster_size,
#                "_r_p", resource_prob,
"_r_size", resource_cluster_size,collapse="",sep="")
set.seed(100)
results <- data.frame(
total_length = numeric(),
euclidean = numeric(),
sinuosity = numeric(),
total_cost=numeric(),
cost1 = numeric(),
cost2 = numeric(),
replicate = integer()
)
#preallocate grid
param_grid <- expand.grid(cost0 = cost_tape0,
cost1 = cost_tape1,
c1_fraction=target_open_fraction,
replicate = seq_len(k))
param_grid
n_total <- nrow(param_grid)
param_grid$metadata<-metadata
# Example data frame to store results
param_grid$total_length <- NA
param_grid$euclidean <- NA
param_grid$sinuosity <- NA
param_grid$total_cost <- NA
for(i in 1:nrow(param_grid)){
#output <- model_landscape_and_movement_v8(n, mod, param_grid$cost1[i],param_grid$cost2[i])
output <- model_landscape_and_movement(grid_size=n,
mod=mod,
cost0=param_grid$cost0[i],
cost1=param_grid$cost1[i],
c1_fraction =param_grid$c1_fraction[i],
c1_cluster_size = closed_cluster_size,
resource_cluster_size=resource_cluster_size)
if (is.null(output)) {
next  # skip this iteration
}
# calculate metrics
metrics <- calculate_path_metrics(output[[1]], output[[2]])
# store results
param_grid$total_length[i] <- metrics$total_length
param_grid$euclidean[i] <- metrics$euclidean
param_grid$sinuosity[i] <- metrics$sinuosity
param_grid$total_cost[i] <- metrics$total_cost
}
param_grid
# sim_fast.R
library(terra)
library(raster)
library(gdistance)
library(here)
library(doParallel)    # optional for parallel runs
library(foreach)
# Source the fast functions file
source("functions_V4.R")
# ----------- parameters -------------
n <- 100
mod <- 5
k <- 5
cost_tape0 <- c(1)
cost_tape1 <- c(1.5, 2.5, 3.5, 4.5)
target_open_fraction <- c(.1, .2, .3, .4)  # earlier you used 'c1_fraction' naming
closed_cluster_size <- 5
resource_cluster_size <- 5
# metadata
metadata <- paste0("targ", paste(target_open_fraction, collapse="-"),
"_cl_size", closed_cluster_size, "_r_size", resource_cluster_size)
# parameter grid
param_grid <- expand.grid(cost0 = cost_tape0,
cost1 = cost_tape1,
c1_fraction = target_open_fraction,
replicate = seq_len(k),
KEEP.OUT.ATTRS = FALSE,
stringsAsFactors = FALSE)
param_grid$metadata <- metadata
param_grid$total_length <- NA_real_
param_grid$euclidean <- NA_real_
param_grid$sinuosity <- NA_real_
param_grid$total_cost <- NA_real_
# ----------- precompute the raster_template for the CROPPED domain -------------
# cropped domain dimensions
n_crop <- n - 2 * mod
if (n_crop <= 0) stop("mod too large relative to grid size")
# build raster::RasterLayer template that matches the cropped extent
r_template <- raster::raster(nrows = n_crop, ncols = n_crop,
xmn = mod, xmx = n - mod, ymn = mod, ymx = n - mod)
# set an initial value (not necessary) but ensures geometry is correct
r_template <- raster::setValues(r_template, rep(NA_real_, raster::ncell(r_template)))
# ---------- optional: parallel setup ----------
use_parallel <- FALSE
if (use_parallel) {
cores <- parallel::detectCores()
cl <- makeCluster(max(1, cores - 1))
doParallel::registerDoParallel(cl)
}
# ---------- main loop (can be run with foreach %dopar% if use_parallel = TRUE) ----------
iter_seq <- seq_len(nrow(param_grid))
if (!use_parallel) {
for (i in iter_seq) {
message(sprintf("iter %d/%d : cost0=%g cost1=%g c1_fraction=%g replicate=%d",
i, nrow(param_grid), param_grid$cost0[i], param_grid$cost1[i],
param_grid$c1_fraction[i], param_grid$replicate[i]))
out <- model_landscape_and_movement_fast(grid_size = n,
mod = mod,
cost0 = param_grid$cost0[i],
cost1 = param_grid$cost1[i],
c1_fraction = param_grid$c1_fraction[i],
c1_cluster_size = closed_cluster_size,
resource_cluster_size = resource_cluster_size,
raster_template = r_template)
if (is.null(out)) next
# calculate metrics
metrics <- calculate_path_metrics(out[[1]], out[[2]])
param_grid$total_length[i] <- metrics$total_length
param_grid$euclidean[i] <- metrics$euclidean
param_grid$sinuosity[i] <- metrics$sinuosity
param_grid$total_cost[i] <- metrics$total_cost
}
} else {
# parallel version (returns list rows -> combine back)
res_list <- foreach(i = iter_seq, .packages = c("terra","raster","gdistance","sp","sf")) %dopar% {
out <- model_landscape_and_movement_fast(grid_size = n,
mod = mod,
cost0 = param_grid$cost0[i],
cost1 = param_grid$cost1[i],
c1_fraction = param_grid$c1_fraction[i],
c1_cluster_size = closed_cluster_size,
resource_cluster_size = resource_cluster_size,
raster_template = r_template)
if (is.null(out)) return(NULL)
metrics <- calculate_path_metrics(out[[1]], out[[2]])
data.frame(total_length = metrics$total_length,
euclidean = metrics$euclidean,
sinuosity = metrics$sinuosity,
total_cost = metrics$total_cost,
i = i)
}
# merge back results
for (r in res_list) {
if (is.null(r)) next
row_i <- r$i
param_grid$total_length[row_i] <- r$total_length
param_grid$euclidean[row_i] <- r$euclidean
param_grid$sinuosity[row_i] <- r$sinuosity
param_grid$total_cost[row_i] <- r$total_cost
}
stopCluster(cl)
}
library(ggplot2)
library(tidybayes)
library(ggridges)
#Basic plots.
df<-param_grid
length(df$cost0)
df <- df[df$total_length > 0, ]
df <- df[which(df$total_cost>0),]
df$rat <- df$total_cost / df$total_length
ggplot(df, aes(x=rat,y=as.factor(c1_fraction),fill=as.factor(c1_fraction)))+geom_density_ridges()+
facet_wrap(~cost1)
ggplot(df, aes(x=sinuosity,y=as.factor(c1_fraction),fill=as.factor(c1_fraction)))+geom_density_ridges()+
facet_wrap(~cost1)
# sim_fast.R
library(terra)
library(raster)
library(gdistance)
library(here)
library(doParallel)    # optional for parallel runs
library(foreach)
# Source the fast functions file
source("functions_V4.R")
# ----------- parameters -------------
n <- 100
mod <- 5
k <- 50
cost_tape0 <- c(1)
cost_tape1 <- c(1.5, 2.5, 3.5, 4.5)
target_open_fraction <- c(.1, .2, .3, .4)  # earlier you used 'c1_fraction' naming
closed_cluster_size <- 5
resource_cluster_size <- 5
# metadata
metadata <- paste0("targ", paste(target_open_fraction, collapse="-"),
"_cl_size", closed_cluster_size, "_r_size", resource_cluster_size)
# parameter grid
param_grid <- expand.grid(cost0 = cost_tape0,
cost1 = cost_tape1,
c1_fraction = target_open_fraction,
replicate = seq_len(k),
KEEP.OUT.ATTRS = FALSE,
stringsAsFactors = FALSE)
param_grid$metadata <- metadata
param_grid$total_length <- NA_real_
param_grid$euclidean <- NA_real_
param_grid$sinuosity <- NA_real_
param_grid$total_cost <- NA_real_
# ----------- precompute the raster_template for the CROPPED domain -------------
# cropped domain dimensions
n_crop <- n - 2 * mod
if (n_crop <= 0) stop("mod too large relative to grid size")
# build raster::RasterLayer template that matches the cropped extent
r_template <- raster::raster(nrows = n_crop, ncols = n_crop,
xmn = mod, xmx = n - mod, ymn = mod, ymx = n - mod)
# set an initial value (not necessary) but ensures geometry is correct
r_template <- raster::setValues(r_template, rep(NA_real_, raster::ncell(r_template)))
# ---------- optional: parallel setup ----------
use_parallel <- FALSE
if (use_parallel) {
cores <- parallel::detectCores()
cl <- makeCluster(max(1, cores - 1))
doParallel::registerDoParallel(cl)
}
# ---------- main loop (can be run with foreach %dopar% if use_parallel = TRUE) ----------
iter_seq <- seq_len(nrow(param_grid))
if (!use_parallel) {
for (i in iter_seq) {
message(sprintf("iter %d/%d : cost0=%g cost1=%g c1_fraction=%g replicate=%d",
i, nrow(param_grid), param_grid$cost0[i], param_grid$cost1[i],
param_grid$c1_fraction[i], param_grid$replicate[i]))
out <- model_landscape_and_movement_fast(grid_size = n,
mod = mod,
cost0 = param_grid$cost0[i],
cost1 = param_grid$cost1[i],
c1_fraction = param_grid$c1_fraction[i],
c1_cluster_size = closed_cluster_size,
resource_cluster_size = resource_cluster_size,
raster_template = r_template)
if (is.null(out)) next
# calculate metrics
metrics <- calculate_path_metrics(out[[1]], out[[2]])
param_grid$total_length[i] <- metrics$total_length
param_grid$euclidean[i] <- metrics$euclidean
param_grid$sinuosity[i] <- metrics$sinuosity
param_grid$total_cost[i] <- metrics$total_cost
}
} else {
# parallel version (returns list rows -> combine back)
res_list <- foreach(i = iter_seq, .packages = c("terra","raster","gdistance","sp","sf")) %dopar% {
out <- model_landscape_and_movement_fast(grid_size = n,
mod = mod,
cost0 = param_grid$cost0[i],
cost1 = param_grid$cost1[i],
c1_fraction = param_grid$c1_fraction[i],
c1_cluster_size = closed_cluster_size,
resource_cluster_size = resource_cluster_size,
raster_template = r_template)
if (is.null(out)) return(NULL)
metrics <- calculate_path_metrics(out[[1]], out[[2]])
data.frame(total_length = metrics$total_length,
euclidean = metrics$euclidean,
sinuosity = metrics$sinuosity,
total_cost = metrics$total_cost,
i = i)
}
# merge back results
for (r in res_list) {
if (is.null(r)) next
row_i <- r$i
param_grid$total_length[row_i] <- r$total_length
param_grid$euclidean[row_i] <- r$euclidean
param_grid$sinuosity[row_i] <- r$sinuosity
param_grid$total_cost[row_i] <- r$total_cost
}
stopCluster(cl)
}
#save results
file_name <- paste0(format(Sys.time(), "%Y_%m_%d_%H%M%S_"), metadata, ".csv")
write.csv(param_grid, file_name, row.names = FALSE)
message("Saved results to: ", file_name)
library(ggplot2)
library(tidybayes)
library(ggridges)
#Basic plots.
df<-param_grid
length(df$cost0)
df <- df[df$total_length > 0, ]
df <- df[which(df$total_cost>0),]
df$rat <- df$total_cost / df$total_length
ggplot(df, aes(x=rat,y=as.factor(c1_fraction),fill=as.factor(c1_fraction)))+geom_density_ridges()+
facet_wrap(~cost1)
ggplot(df, aes(x=sinuosity,y=as.factor(c1_fraction),fill=as.factor(c1_fraction)))+geom_density_ridges()+
facet_wrap(~cost1)
ggplot(df, aes(x=sinuosity,y=as.factor(c1_fraction),fill=as.factor(c1_fraction)))+geom_density_ridges()+
facet_wrap(~cost1)
ggplot(df, aes(x=rat,y=as.factor(c1_fraction),fill=as.factor(c1_fraction)))+geom_density_ridges()+
facet_wrap(~cost1)
ggplot(df, aes(x=rat,y=as.factor(c1_fraction),fill=as.factor(c1_fraction)))+geom_density_ridges()+
facet_wrap(~cost1)
ggplot(df, aes(x=sinuosity,y=as.factor(c1_fraction),fill=as.factor(c1_fraction)))+geom_density_ridges()+
facet_wrap(~cost1)
ggplot(df, aes(x=rat,y=as.factor(c1_fraction),fill=as.factor(c1_fraction)))+geom_density_ridges()+
facet_wrap(~cost1)
ggplot(df, aes(x=sinuosity, y=total_length))+geom_point()
ggplot(df, aes(x=sinuosity, y=total_length))+geom_point()+facet_wrap(~c1_fraction)
ggplot(df, aes(x=total_cost, y=total_length))+geom_point()+facet_wrap(~c1_fraction)
ggplot(df, aes(x=total_cost, y=total_length))+geom_point()+facet_wrap(~c1)
ggplot(df, aes(x=total_cost, y=total_length))+geom_point()+facet_wrap(~cost1)
